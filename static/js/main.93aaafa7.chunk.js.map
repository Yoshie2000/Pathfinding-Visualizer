{"version":3,"sources":["PathfindingVisualizer/Node/Node.js","algorithms/dijkstra.js","algorithms/astar.js","algorithms/recursivedivision.js","algorithms/recursivebacktracking.js","algorithms/breadthfirstsearch.js","algorithms/depthfirstsearch.js","algorithms/greedy.js","PathfindingVisualizer/PathfindingVisualizer.js","algorithms/simplewall.js","App.js","serviceWorker.js","index.js"],"names":["Node","this","props","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","row","extraClassName","id","className","e","preventDefault","stopPropagation","Component","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","parent","getNodeWithLowestScore","openList","lowestScoreNode","f","getWalkableNeighbors","heuristic","endNode","Math","sqrt","removeNodeFromArray","array","i","splice","recursiveDivision","totalWidth","totalHeight","wallsInOrder","x","y","width","height","divide","orientation","horizontal","wallX","floor","random","wallY","passageX","passageY","deltaX","deltaY","dir","makeWall","nextWidth1","nextHeight1","chooseOrientation","nextWidth2","nextHeight2","wallsToRemove","pX","pY","wallNode","removeWall","neighbour","n1","n2","dirX","dirY","getNeighbourDirection","getUnvisitedNeighbours","result","neighbours","getNeighbours","isMazeVisited","hasUnvisitedCells","getNodeWithShortestDistance","queue","gridWidth","gridHeight","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","PathfindingVisualizer","state","algorithm","tempGrid","mouseIsPressed","toggleMode","dragData","walls","mousePressed","lastSortType","resetGrid","newGrid","currentX","currentY","simpleWall","stack","newNode","pop","recursiveBacktracking","alert","setTimeout","updateNodeClassNames","setState","callback","previousNode","isMazeVisitedVisited","document","getElementById","getNodeClassNames","getInitialGrid","resetGridData","getNewGridWithWallToggled","lastNode","updateStartAndFinishPositions","visualizeSorting","instant","g","h","currentNode","closedList","firstNeighbors","includes","astar","neighbourNode","breadthfirstsearch","depthfirstsearch","greedy","nodesInShortestPathOrder","unshift","getNodesInShortestPathOrder","animateSorting","animateShortestPath","replace","href","type","data-toggle","data-target","aria-controls","aria-expanded","aria-label","role","aria-haspopup","aria-labelledby","onClick","setAlgorithm","generateMaze","generateNavbar","map","rowIdx","key","nodeIdx","wall","handleMouseDown","handleMouseEnter","handleMouseUp","window","innerWidth","innerHeight","currentRow","createNode","slice","newStartNodeRow","newStartNodeCol","newFinishNodeRow","newFinishNodeCol","App","Boolean","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.93aaafa7.chunk.js","sourcesContent":["import React, { Component } from 'react';\r\n\r\nimport './Node.css';\r\n\r\nexport default class Node extends Component {\r\n\trender() {\r\n\t\tconst {\r\n\t\t\tcol,\r\n\t\t\tisFinish,\r\n\t\t\tisStart,\r\n\t\t\tisWall,\r\n\t\t\tonMouseDown,\r\n\t\t\tonMouseEnter,\r\n\t\t\tonMouseUp,\r\n\t\t\trow,\r\n\t\t} = this.props;\r\n\r\n\t\tlet extraClassName = '';\r\n\t\textraClassName += isFinish ? ' node-finish' : '';\r\n\t\textraClassName += isStart ? ' node-start' : '';\r\n\t\textraClassName += isWall ? ' node-wall' : '';\r\n\r\n\t\treturn (\r\n\t\t\t<div\r\n\t\t\t\tid={`node-${row}-${col}`}\r\n\t\t\t\tclassName={`node${extraClassName}`}\r\n\t\t\t\tonMouseDown={(e) => { onMouseDown(row, col, isWall); e.preventDefault(); e.stopPropagation(); }}\r\n\t\t\t\tonMouseEnter={(e) => {\r\n\t\t\t\t\tonMouseEnter(row, col); e.preventDefault(); e.stopPropagation();\r\n\t\t\t\t}}\r\n\t\t\t\tonMouseUp={(e) => { onMouseUp(); e.preventDefault(); e.stopPropagation(); }}></div>\r\n\t\t);\r\n\t}\r\n}","// Performs Dijkstra's algorithm; returns *all* nodes in the order\r\n// in which they were visited. Also makes nodes point back to their\r\n// previous node, effectively allowing us to compute the shortest path\r\n// by backtracking from the finish node.\r\nexport function dijkstra(grid, startNode, finishNode) {\r\n    const visitedNodesInOrder = [];\r\n    startNode.distance = 0;\r\n    const unvisitedNodes = getAllNodes(grid);\r\n\r\n    while (!!unvisitedNodes.length) {\r\n        sortNodesByDistance(unvisitedNodes);\r\n        const closestNode = unvisitedNodes.shift();\r\n        // If we encounter a wall, we skip it.\r\n        if (closestNode.isWall)\r\n            continue;\r\n        // If the closest node is at a distance of infinity,\r\n        // we must be trapped and should therefore stop.\r\n        if (closestNode.distance === Infinity)\r\n            return visitedNodesInOrder;\r\n\r\n        closestNode.isVisited = true;\r\n        visitedNodesInOrder.push(closestNode);\r\n\r\n        if (closestNode === finishNode)\r\n            return visitedNodesInOrder;\r\n\r\n        updateUnvisitedNeighbors(closestNode, grid);\r\n    }\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n    for (const neighbor of unvisitedNeighbors) {\r\n        neighbor.distance = node.distance + 1;\r\n        neighbor.parent = node;\r\n    }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const { col, row } = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n    const nodes = [];\r\n    for (const row of grid) {\r\n        for (const node of row) {\r\n            nodes.push(node);\r\n        }\r\n    }\r\n    return nodes;\r\n}\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// Only works when called *after* the dijkstra method above.\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode) {\r\n        nodesInShortestPathOrder.unshift(currentNode);\r\n        currentNode = currentNode.parent;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n}","\r\nexport function astar(grid, startNode, endNode) {\r\n    const visitedNodesInOrder = [];\r\n\r\n    startNode.g = 0;\r\n    startNode.h = heuristic(startNode, endNode);\r\n    startNode.f = startNode.g + startNode.h;\r\n    startNode.isVisited = true;\r\n\r\n    let currentNode = startNode;\r\n    let openList = [], closedList = [];\r\n\r\n    closedList.push(currentNode);\r\n    visitedNodesInOrder.push(currentNode);\r\n\r\n    let firstNeighbors = getWalkableNeighbors(grid, currentNode);\r\n    for (let neighbor of firstNeighbors) {\r\n        neighbor.g = currentNode.g + 1;\r\n        neighbor.h = heuristic(neighbor, endNode);\r\n        neighbor.f = neighbor.g + neighbor.h;\r\n        neighbor.parent = currentNode;\r\n        neighbor.isVisited = true;\r\n        openList.push(neighbor);\r\n        visitedNodesInOrder.push(neighbor);\r\n    }\r\n\r\n    while (openList.length > 0) {\r\n        currentNode = getNodeWithLowestScore(openList);\r\n        removeNodeFromArray(openList, currentNode);\r\n        closedList.push(currentNode);\r\n\r\n        currentNode.isVisited = true;\r\n        visitedNodesInOrder.push(currentNode);\r\n\r\n        if (currentNode.col === endNode.col && currentNode.row === endNode.row)\r\n            break;\r\n\r\n        let neighbors = getWalkableNeighbors(grid, currentNode);\r\n        for (let neighbor of neighbors) {\r\n            if (closedList.includes(neighbor))\r\n                continue;\r\n\r\n            neighbor.isVisited = true;\r\n            visitedNodesInOrder.push(neighbor);\r\n\r\n            if (!openList.includes(neighbor)) {\r\n                neighbor.g = currentNode.g + 1;\r\n                neighbor.h = heuristic(neighbor, endNode);\r\n                neighbor.f = neighbor.g + neighbor.h;\r\n                neighbor.parent = currentNode;\r\n                openList.push(neighbor);\r\n            } else {\r\n                const newF = currentNode.g + 1 + heuristic(neighbor, endNode);\r\n                if (newF < neighbor.f) {\r\n                    neighbor.g = currentNode.g + 1;\r\n                    neighbor.h = heuristic(neighbor, endNode);\r\n                    neighbor.f = neighbor.g + neighbor.h;\r\n                    neighbor.parent = currentNode;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return visitedNodesInOrder;\r\n}\r\n\r\nfunction getNodeWithLowestScore(openList) {\r\n    let lowestScoreNode;\r\n\r\n    for (let node of openList) {\r\n        if (!lowestScoreNode || node.f < lowestScoreNode.f) {\r\n            lowestScoreNode = node;\r\n        }\r\n    }\r\n    return lowestScoreNode;\r\n}\r\n\r\nfunction getWalkableNeighbors(grid, node) {\r\n    const neighbors = [];\r\n    const { col, row } = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    return neighbors.filter(neighbor => !neighbor.isWall);\r\n}\r\n\r\nfunction heuristic(node, endNode) {\r\n    return Math.sqrt(\r\n        (node.row - endNode.row) * (node.row - endNode.row) +\r\n        (node.col - endNode.col) * (node.col - endNode.col)\r\n    );\r\n}\r\n\r\nfunction removeNodeFromArray(array, node) {\r\n    for (let i = 0; i < array.length; i++) {\r\n        if (array[i] === node) {\r\n            array.splice(i, 1);\r\n            break;\r\n        }\r\n    }\r\n}","\r\nexport function recursiveDivision(grid, totalWidth, totalHeight, startNode, endNode) {\r\n\r\n    let wallsInOrder = [];\r\n\r\n    // Draw border\r\n    for (let x = 0; x < totalWidth; x++) {\r\n        for (let y = 0; y < totalHeight; y++) {\r\n            if ((x % 2 === 0 && y % 2 === 0) || (x === 0 || y === 0 || x === totalWidth - 1 || y === totalHeight - 1)) {\r\n                wallsInOrder.push(grid[y][x]);\r\n            }\r\n        }\r\n    }\r\n\r\n    let width = totalWidth / 2 - 1;\r\n    let height = totalHeight / 2 - 1;\r\n\r\n    divide(grid, 0, 0, width, height, chooseOrientation(width, height), width, height, startNode, endNode, wallsInOrder);\r\n\r\n    return {\r\n        wallsInOrder: wallsInOrder,\r\n        wallsToRemove: null\r\n    };\r\n}\r\n\r\nfunction divide(grid, x, y, width, height, orientation, totalWidth, totalHeight, startNode, endNode, wallsInOrder) {\r\n    if (width < 2 || height < 2 || x < 0 || x >= totalWidth || y < 0 || y >= totalHeight)\r\n        return;\r\n\r\n    const horizontal = orientation === \"HORIZONTAL\";\r\n\r\n    // Determine the start coordinates of the wall\r\n    let wallX = x + (horizontal ? 0 : Math.floor(Math.random() * (width - 1)));\r\n    let wallY = y + (horizontal ? Math.floor(Math.random() * (height - 1)) : 0);\r\n\r\n    // Determine the coordinates of the passage\r\n    const passageX = wallX + (horizontal ? Math.floor(Math.random() * width) : 0);\r\n    const passageY = wallY + (horizontal ? 0 : Math.floor(Math.random() * height));\r\n\r\n    // Determine the delta coordinates\r\n    const deltaX = horizontal ? 1 : 0;\r\n    const deltaY = horizontal ? 0 : 1;\r\n\r\n    const length = horizontal ? width : height;\r\n\r\n    const dir = horizontal ? \"SOUTH\" : \"EAST\";\r\n\r\n    for (let i = 0; i < length; i++) {\r\n        let currentX = wallX + (deltaX * i);\r\n        let currentY = wallY + (deltaY * i);\r\n\r\n        makeWall(grid, currentX, currentY, passageX, passageY, dir, wallsInOrder);\r\n    }\r\n\r\n    let nextX1 = x;\r\n    let nextY1 = y;\r\n    let nextWidth1 = horizontal ? width : wallX - x + 1;\r\n    let nextHeight1 = horizontal ? wallY - y + 1 : height;\r\n    divide(grid, nextX1, nextY1, nextWidth1, nextHeight1, chooseOrientation(nextWidth1, nextHeight1), totalWidth, totalHeight, startNode, endNode, wallsInOrder);\r\n\r\n    let nextX2 = horizontal ? x : wallX + 1;\r\n    let nextY2 = horizontal ? wallY + 1 : y;\r\n    let nextWidth2 = horizontal ? width : x + width - wallX - 1;\r\n    let nextHeight2 = horizontal ? y + height - wallY - 1 : height;\r\n    divide(grid, nextX2, nextY2, nextWidth2, nextHeight2, chooseOrientation(nextWidth2, nextHeight2), totalWidth, totalHeight, startNode, endNode, wallsInOrder);\r\n}\r\n\r\nfunction chooseOrientation(width, height) {\r\n    if (width < height)\r\n        return \"HORIZONTAL\";\r\n    else if (height < width)\r\n        return \"VERTICAL\";\r\n    else\r\n        return Math.random() >= 0.5 ? \"HORIZONTAL\" : \"VERTICAL\";\r\n}\r\n\r\nfunction makeWall(grid, x, y, pX, pY, dir, wallsInOrder) {\r\n    let wallNode;\r\n    if (dir === \"SOUTH\") {\r\n        wallNode = grid[2 * (y + 1)][2 * x + 1];\r\n    } else if (dir === \"EAST\") {\r\n        wallNode = grid[2 * y + 1][2 * (x + 1)];\r\n    }\r\n\r\n    if (wallNode) {\r\n        if (x !== pX || y !== pY)\r\n            wallsInOrder.push(wallNode);\r\n    }\r\n}","\r\nexport function recursiveBacktracking(grid, totalWidth, totalHeight) {\r\n\r\n    let wallsInOrder = [];\r\n    let wallsToRemove = [];\r\n\r\n    // Draw border\r\n    for (let x = 0; x < totalWidth; x++) {\r\n        for (let y = 0; y < totalHeight; y++) {\r\n            if (x % 2 === 0 || y % 2 === 0) {\r\n                wallsInOrder.push(grid[y][x]);\r\n            }\r\n        }\r\n    }\r\n\r\n    let stack = [];\r\n    let node = grid[0][0];\r\n\r\n    node.isMazeVisited = true;\r\n\r\n    while (hasUnvisitedCells(grid)) {\r\n        let neighbours = getUnvisitedNeighbours(grid, node);\r\n\r\n        if (neighbours.length > 0) {\r\n\r\n            if (neighbours.length > 1) {\r\n                stack.push(node);\r\n            }\r\n\r\n            let randomIndex = Math.floor(Math.random() * neighbours.length);\r\n            let neighbour = neighbours[randomIndex];\r\n\r\n            wallsToRemove = removeWall(grid, node, neighbour, wallsToRemove);\r\n\r\n            neighbour.isMazeVisited = true;\r\n            node = neighbour;\r\n        } else if (stack.length > 0) {\r\n            let newNode;\r\n            while (stack.length > 0) {\r\n                newNode = stack.pop();\r\n                if (getUnvisitedNeighbours(grid, newNode).length !== 0)\r\n                    break;\r\n            }\r\n            node = newNode;\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n\r\n    return {\r\n        wallsInOrder: wallsInOrder,\r\n        wallsToRemove: wallsToRemove\r\n    };\r\n}\r\n\r\nfunction removeWall(grid, node, neighbour, wallsToRemove) {\r\n    const dir = getNeighbourDirection(node, neighbour);\r\n\r\n    const x = node.col, y = node.row;\r\n    let wallNode;\r\n\r\n    //let walls = [];\r\n\r\n    if (dir.x > 0) {\r\n        // EAST\r\n        wallNode = grid[2 * y + 1][2 * (x + 1)];\r\n\r\n        /*walls.push(grid[2 * y + 1][2 * x]);\r\n        walls.push(grid[2 * (y + 1)][2 * x + 1]);\r\n        walls.push(grid[2 * y][2 * x + 1]);*/\r\n    } else if (dir.x < 0) {\r\n        // WEST\r\n        wallNode = grid[2 * y + 1][2 * x];\r\n\r\n        /*walls.push(grid[2 * y + 1][2 * (x + 1)]);\r\n        walls.push(grid[2 * (y + 1)][2 * x + 1]);\r\n        walls.push(grid[2 * y][2 * x + 1]);*/\r\n    } else if (dir.y > 0) {\r\n        // SOUTH\r\n        wallNode = grid[2 * (y + 1)][2 * x + 1];\r\n\r\n        /*walls.push(grid[2 * y + 1][2 * (x + 1)]);\r\n        walls.push(grid[2 * y + 1][2 * x]);\r\n        walls.push(grid[2 * y][2 * x + 1]);*/\r\n    } else if (dir.y < 0) {\r\n        // NORTH\r\n        wallNode = grid[2 * y][2 * x + 1];\r\n\r\n        /*walls.push(grid[2 * y + 1][2 * (x + 1)]);\r\n        walls.push(grid[2 * y + 1][2 * x]);\r\n        walls.push(grid[2 * (y + 1)][2 * x + 1]);*/\r\n    }\r\n\r\n    if (wallNode) {\r\n        wallsToRemove.push(wallNode);\r\n    }\r\n\r\n    /*for (let wall of walls) {\r\n        wallsInOrder.push(wall);\r\n    }*/\r\n\r\n    return wallsToRemove;\r\n}\r\n\r\nfunction getNeighbourDirection(n1, n2) {\r\n    let dirX = n2.col - n1.col;\r\n    let dirY = n2.row - n1.row;\r\n    return { x: dirX, y: dirY };\r\n}\r\n\r\nfunction getNeighbours(grid, node) {\r\n    let { col, row } = node;\r\n\r\n    let neighbours = [];\r\n    if (row > 0) {\r\n        neighbours.push(grid[row - 1][col]);\r\n    }\r\n    if (row < grid.length / 2 - 2) {\r\n        neighbours.push(grid[row + 1][col]);\r\n    }\r\n    if (col > 0) {\r\n        neighbours.push(grid[row][col - 1]);\r\n    }\r\n    if (col < grid[row].length / 2 - 2) {\r\n        neighbours.push(grid[row][col + 1]);\r\n    }\r\n    return neighbours;\r\n}\r\n\r\nfunction getUnvisitedNeighbours(grid, node) {\r\n    let result = [];\r\n    for (let neighbour of getNeighbours(grid, node)) {\r\n        if (neighbour && !neighbour.isMazeVisited) {\r\n            result.push(neighbour);\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\nfunction hasUnvisitedCells(grid) {\r\n    for (let row of grid) {\r\n        for (let node of row) {\r\n            if (!node.isMazeVisited)\r\n                return true;\r\n        }\r\n    }\r\n    return false;\r\n}","\r\nexport function breadthfirstsearch(grid, startNode, endNode) {\r\n\r\n    let visitedNodesInOrder = [];\r\n    let queue = [];\r\n\r\n    queue.push(startNode);\r\n    visitedNodesInOrder.push(startNode);\r\n    startNode.isVisited = true;\r\n\r\n    while (queue.length > 0) {\r\n        \r\n        let node = queue.pop();\r\n\r\n        for (let neighbourNode of getUnvisitedNeighbours(grid, node)) {\r\n            if (!visitedNodesInOrder.includes(neighbourNode))\r\n                visitedNodesInOrder.push(neighbourNode);\r\n            neighbourNode.isVisited = true;\r\n            neighbourNode.parent = node;\r\n\r\n            if (neighbourNode === endNode)\r\n                return visitedNodesInOrder;\r\n            else\r\n                queue.push(neighbourNode);\r\n\r\n        }\r\n\r\n    }\r\n\r\n    return visitedNodesInOrder;\r\n}\r\n\r\nfunction getUnvisitedNeighbours(grid, node) {\r\n    const neighbors = [];\r\n    const { col, row } = node;\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    return neighbors.filter(neighbor => !neighbor.isVisited && !neighbor.isWall);\r\n}","\r\nexport function depthfirstsearch(grid, startNode, endNode) {\r\n\r\n    let visitedNodesInOrder = [];\r\n    let queue = [];\r\n\r\n    queue.push(startNode);\r\n\r\n    while (queue.length > 0) {\r\n\r\n        let node = queue.pop();\r\n        node.isVisited = true;\r\n\r\n        if (!visitedNodesInOrder.includes(node))\r\n            visitedNodesInOrder.push(node);\r\n\r\n        for (let neighbourNode of getUnvisitedNeighbours(grid, node)) {\r\n            neighbourNode.parent = node;\r\n\r\n            if (neighbourNode === endNode)\r\n                return visitedNodesInOrder;\r\n            else\r\n                queue.push(neighbourNode);\r\n\r\n        }\r\n\r\n    }\r\n\r\n    return visitedNodesInOrder;\r\n}\r\n\r\nfunction getUnvisitedNeighbours(grid, node) {\r\n    const neighbors = [];\r\n    const { col, row } = node;\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    return neighbors.filter(neighbor => !neighbor.isVisited && !neighbor.isWall);\r\n}","\r\nexport function greedy(grid, startNode, endNode) {\r\n    const visitedNodesInOrder = [];\r\n\r\n    for (let row of grid) {\r\n        for (let node of row) {\r\n            node.distance = Infinity;\r\n        }\r\n    }\r\n\r\n    startNode.distance = heuristic(startNode, endNode);\r\n\r\n    let queue = [];\r\n    queue.push(startNode);\r\n\r\n    while (queue.length > 0) {\r\n        let currentNode = getNodeWithShortestDistance(queue);\r\n        removeNodeFromArray(queue, currentNode);\r\n        currentNode.isVisited = true;\r\n        visitedNodesInOrder.push(currentNode);\r\n\r\n        if (currentNode.row === endNode.row && currentNode.col === endNode.col) {\r\n            return visitedNodesInOrder;\r\n        }\r\n\r\n        let neighbors = getWalkableNeighbors(grid, currentNode);\r\n\r\n        for (let neighbor of neighbors) {\r\n            if (neighbor.isVisited)\r\n                continue;\r\n            neighbor.distance = heuristic(neighbor, endNode);\r\n            neighbor.parent = currentNode;\r\n            queue.push(neighbor);\r\n        }\r\n\r\n    }\r\n\r\n    return visitedNodesInOrder;\r\n}\r\n\r\nfunction getNodeWithShortestDistance(queue) {\r\n    let lowestScoreNode;\r\n\r\n    for (let node of queue) {\r\n        if (!lowestScoreNode || node.distance < lowestScoreNode.distance) {\r\n            lowestScoreNode = node;\r\n        }\r\n    }\r\n    return lowestScoreNode;\r\n}\r\n\r\nfunction getWalkableNeighbors(grid, node) {\r\n    const neighbors = [];\r\n    const { col, row } = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    return neighbors.filter(neighbor => !neighbor.isWall);\r\n}\r\n\r\nfunction heuristic(node, endNode) {\r\n    return Math.sqrt(\r\n        (node.row - endNode.row) * (node.row - endNode.row) +\r\n        (node.col - endNode.col) * (node.col - endNode.col)\r\n    );\r\n}\r\n\r\nfunction removeNodeFromArray(array, node) {\r\n    for (let i = 0; i < array.length; i++) {\r\n        if (array[i] === node) {\r\n            array.splice(i, 1);\r\n            break;\r\n        }\r\n    }\r\n}","import React, { Component } from 'react';\r\nimport Node from './Node/Node';\r\nimport { dijkstra, getNodesInShortestPathOrder } from './../algorithms/dijkstra';\r\nimport { astar } from './../algorithms/astar';\r\nimport { recursiveDivision } from './../algorithms/recursivedivision';\r\nimport { recursiveBacktracking } from './../algorithms/recursivebacktracking';\r\nimport { breadthfirstsearch } from '../algorithms/breadthfirstsearch';\r\nimport './PathfindingVisualizer.css';\r\nimport { depthfirstsearch } from '../algorithms/depthfirstsearch';\r\nimport { simpleWall } from '../algorithms/simplewall';\r\nimport { greedy } from '../algorithms/greedy';\r\n\r\nlet START_NODE_ROW = 10;\r\nlet START_NODE_COL = 15;\r\nlet FINISH_NODE_ROW = 10;\r\nlet FINISH_NODE_COL = 35;\r\nlet gridWidth, gridHeight;\r\n\r\nexport default class PathfindingVisualizer extends Component {\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.state = {\r\n\t\t\tgrid: [],\r\n\t\t\talgorithm: \"A*\"\r\n\t\t};\r\n\t\tthis.tempGrid = [];\r\n\t\tthis.mouseIsPressed = false;\r\n\t\tthis.toggleMode = true;\r\n\t\tthis.dragData = {\r\n\t\t\twalls: true,\r\n\t\t\tmousePressed: false,\r\n\t\t\ttempGrid: [],\r\n\t\t\tstartNode: null\r\n\t\t}\r\n\t\tthis.lastSortType = null;\r\n\t}\r\n\r\n\tcomponentDidMount() {\r\n\t\tthis.resetGrid();\r\n\t}\r\n\r\n\tgenerateMaze(algorithm) {\r\n\r\n\t\tthis.resetGrid(() => {\r\n\t\t\tlet result;\r\n\t\t\tlet newGrid = this.state.grid;\r\n\r\n\t\t\tswitch (algorithm) {\r\n\t\t\t\tcase \"Simple Wall\":\r\n\t\t\t\t\tresult = simpleWall(newGrid, gridWidth, gridHeight);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"Recursive Division\":\r\n\t\t\t\t\tresult = recursiveDivision(newGrid, gridWidth, gridHeight, newGrid[START_NODE_ROW][START_NODE_COL], newGrid[FINISH_NODE_ROW][FINISH_NODE_COL]);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"Recursive Backtracking\":\r\n\t\t\t\t\tresult = recursiveBacktracking(newGrid, gridWidth, gridHeight);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\talert(\"No maze generation algorithm selected\");\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tlet { wallsInOrder, wallsToRemove } = result;\r\n\r\n\t\t\tif (wallsToRemove) {\r\n\t\t\t\tfor (let i = 0; i < wallsInOrder.length; i++) {\r\n\t\t\t\t\tsetTimeout(() => {\r\n\t\t\t\t\t\tlet node = wallsInOrder[i];\r\n\t\t\t\t\t\tnode.isWall = node.isStart || node.isFinish ? false : true;\r\n\t\t\t\t\t\tthis.updateNodeClassNames(node);\r\n\t\t\t\t\t}, i * 2.5);\r\n\t\t\t\t\tnewGrid[wallsInOrder[i].row][wallsInOrder[i].col] = wallsInOrder[i];\r\n\t\t\t\t}\r\n\t\t\t\tsetTimeout(() => {\r\n\t\t\t\t\tfor (let i = 0; i < wallsToRemove.length; i++) {\r\n\t\t\t\t\t\tsetTimeout(() => {\r\n\t\t\t\t\t\t\tlet node = wallsToRemove[i];\r\n\t\t\t\t\t\t\tnode.isWall = false;\r\n\t\t\t\t\t\t\tthis.updateNodeClassNames(node);\r\n\t\t\t\t\t\t}, i * 25);\r\n\t\t\t\t\t\tnewGrid[wallsToRemove[i].row][wallsToRemove[i].col] = wallsToRemove[i];\r\n\t\t\t\t\t}\r\n\t\t\t\t}, wallsInOrder.length * 2.5);\r\n\t\t\t} else {\r\n\t\t\t\tfor (let i = 0; i < wallsInOrder.length; i++) {\r\n\t\t\t\t\tsetTimeout(() => {\r\n\t\t\t\t\t\tlet node = wallsInOrder[i];\r\n\t\t\t\t\t\tnode.isWall = node.isStart || node.isFinish ? false : true;\r\n\t\t\t\t\t\tthis.updateNodeClassNames(node);\r\n\t\t\t\t\t}, i * 10);\r\n\t\t\t\t\tnewGrid[wallsInOrder[i].row][wallsInOrder[i].col] = wallsInOrder[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis.setState({ grid: newGrid });\r\n\t\t});\r\n\t}\r\n\r\n\tresetGridData(callback) {\r\n\t\tlet grid = this.state.grid;\r\n\t\tfor (let row of grid) {\r\n\t\t\tfor (let node of row) {\r\n\t\t\t\tnode.distance = Infinity;\r\n\t\t\t\tnode.previousNode = null;\r\n\t\t\t\tnode.isVisited = false;\r\n\t\t\t\tnode.isMazeVisited = false;\r\n\t\t\t\tnode.isMazeVisitedVisited = false;\r\n\r\n\t\t\t\tif (document.getElementById(`node-${node.row}-${node.col}`)) {\r\n\t\t\t\t\tdocument.getElementById(`node-${node.row}-${node.col}`).className =\r\n\t\t\t\t\t\t'node ' + this.getNodeClassNames(node);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.setState({ grid: grid }, () => {\r\n\t\t\tif (callback)\r\n\t\t\t\tcallback();\r\n\t\t});\r\n\t}\r\n\r\n\tresetGrid(callback) {\r\n\t\tlet newGrid = this.getInitialGrid();\r\n\t\tthis.setState({ grid: newGrid }, () => {\r\n\t\t\tthis.resetGridData(() => {\r\n\t\t\t\tif (callback)\r\n\t\t\t\t\tcallback();\r\n\t\t\t});\r\n\t\t});\r\n\t}\r\n\r\n\thandleMouseDown(row, col, isWall) {\r\n\t\tthis.dragData.walls = !isWall;\r\n\t\tconst newGrid = this.getNewGridWithWallToggled(this.state.grid, row, col);\r\n\t\tthis.dragData = {\r\n\t\t\twalls: !isWall,\r\n\t\t\tmousePressed: true,\r\n\t\t\ttempGrid: newGrid,\r\n\t\t\tlastNode: this.state.grid[row][col]\r\n\t\t};\r\n\t}\r\n\r\n\thandleMouseEnter(row, col) {\r\n\t\tif (!this.dragData.mousePressed) {\r\n\t\t\treturn;\r\n\t\t} else if (this.dragData.lastNode.isStart) {\r\n\t\t\tthis.updateStartAndFinishPositions(row, col, FINISH_NODE_ROW, FINISH_NODE_COL);\r\n\t\t\tif (this.lastSortType)\r\n\t\t\t\tthis.visualizeSorting(true);\r\n\t\t}\r\n\t\telse if (this.dragData.lastNode.isFinish) {\r\n\t\t\tthis.updateStartAndFinishPositions(START_NODE_ROW, START_NODE_COL, row, col);\r\n\t\t\tif (this.lastSortType)\r\n\t\t\t\tthis.visualizeSorting(true);\r\n\t\t} else {\r\n\t\t\tconst newGrid = this.getNewGridWithWallToggled(this.state.grid, row, col);\r\n\t\t\tthis.dragData.tempGrid = newGrid;\r\n\t\t}\r\n\t\tthis.dragData.lastNode = this.dragData.tempGrid[row][col];\r\n\t}\r\n\r\n\thandleMouseUp() {\r\n\t\tif (this.dragData.lastNode.isStart || this.dragData.lastNode.isFinish) {\r\n\t\t\tif (this.lastSortType)\r\n\t\t\t\tthis.visualizeSorting(true);\r\n\t\t}\r\n\r\n\t\tthis.dragData.mousePressed = false;\r\n\t\tthis.setState({ grid: this.dragData.tempGrid });\r\n\t}\r\n\r\n\tsetAlgorithm(algorithm) {\r\n\t\tthis.setState({ algorithm: algorithm });\r\n\t}\r\n\r\n\tvisualizeSorting(instant) {\r\n\t\tthis.resetGridData();\r\n\r\n\t\tconst { grid } = this.state;\r\n\t\tthis.lastSortType = this.state.algorithm;\r\n\t\tconst startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n\t\tconst finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n\r\n\t\tlet visitedNodesInOrder = [];\r\n\t\tswitch (this.state.algorithm) {\r\n\t\t\tcase \"A*\":\r\n\t\t\t\tvisitedNodesInOrder = astar(grid, startNode, finishNode);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"Breadth First Search\":\r\n\t\t\t\tvisitedNodesInOrder = breadthfirstsearch(grid, startNode, finishNode);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"Depth First Search\":\r\n\t\t\t\tvisitedNodesInOrder = depthfirstsearch(grid, startNode, finishNode);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"Dijkstra's\":\r\n\t\t\t\tvisitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"Greedy's\":\r\n\t\t\t\tvisitedNodesInOrder = greedy(grid, startNode, finishNode);\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\talert(\"No sorting algorithm selected\");\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tconst nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n\t\tthis.animateSorting(visitedNodesInOrder, nodesInShortestPathOrder, instant);\r\n\t}\r\n\r\n\tanimateSorting(visitedNodesInOrder, nodesInShortestPathOrder, instant) {\r\n\t\tfor (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n\t\t\tif (instant) {\r\n\t\t\t\tif (i === visitedNodesInOrder.length) {\r\n\t\t\t\t\tthis.animateShortestPath(nodesInShortestPathOrder, instant);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tconst node = visitedNodesInOrder[i];\r\n\t\t\t\tdocument.getElementById(`node-${node.row}-${node.col}`).className = this.getNodeClassNames(node) + (instant ? \" node-instant-animation\" : \"\");\r\n\t\t\t} else {\r\n\t\t\t\tif (i === visitedNodesInOrder.length) {\r\n\t\t\t\t\tsetTimeout(() => {\r\n\t\t\t\t\t\tthis.animateShortestPath(nodesInShortestPathOrder, instant);\r\n\t\t\t\t\t}, 5 * i);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tsetTimeout(() => {\r\n\t\t\t\t\tconst node = visitedNodesInOrder[i];\r\n\t\t\t\t\tdocument.getElementById(`node-${node.row}-${node.col}`).className = this.getNodeClassNames(node) + (instant ? \" node-instant-animation\" : \"\");\r\n\t\t\t\t}, 5 * i);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tanimateShortestPath(nodesInShortestPathOrder, instant) {\r\n\t\tfor (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n\t\t\tif (instant) {\r\n\t\t\t\tconst node = nodesInShortestPathOrder[i];\r\n\r\n\t\t\t\tdocument.getElementById(`node-${node.row}-${node.col}`).className =\r\n\t\t\t\t\t'node-shortest-path ' + this.getNodeClassNames(node).replace(/node-visited/, \"\") + (instant ? \" node-instant-animation\" : \"\");\r\n\t\t\t} else {\r\n\t\t\t\tsetTimeout(() => {\r\n\t\t\t\t\tconst node = nodesInShortestPathOrder[i];\r\n\r\n\t\t\t\t\tdocument.getElementById(`node-${node.row}-${node.col}`).className =\r\n\t\t\t\t\t\t'node-shortest-path ' + this.getNodeClassNames(node).replace(/node-visited/, \"\") + (instant ? \" node-instant-animation\" : \"\");\r\n\t\t\t\t}, instant ? 0 : 25 * i);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tgenerateNavbar() {\r\n\t\treturn (\r\n\t\t\t<nav className=\"navbar navbar-expand-lg navbar-light bg-light\">\r\n\t\t\t\t<a className=\"navbar-brand\" href=\"/\">Pathfinding Visualizer</a>\r\n\t\t\t\t<button className=\"navbar-toggler\" type=\"button\" data-toggle=\"collapse\" data-target=\"#navbarSupportedContent\" aria-controls=\"navbarSupportedContent\" aria-expanded=\"false\" aria-label=\"Toggle navigation\">\r\n\t\t\t\t\t<span className=\"navbar-toggler-icon\"></span>\r\n\t\t\t\t</button>\r\n\r\n\t\t\t\t<div className=\"collapse navbar-collapse\" id=\"navbarSupportedContent\">\r\n\t\t\t\t\t<ul className=\"navbar-nav mr-auto\">\r\n\r\n\t\t\t\t\t\t<li className=\"nav-item dropdown\">\r\n\t\t\t\t\t\t\t<span className=\"nav-link dropdown-toggle\" id=\"algorithmDropdown\" role=\"button\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">Select Algorithm</span>\r\n\t\t\t\t\t\t\t<div className=\"dropdown-menu\" aria-labelledby=\"algorithmDropdown\">\r\n\t\t\t\t\t\t\t\t<span className=\"dropdown-item\" onClick={() => this.setAlgorithm(\"A*\")}>A*</span>\r\n\t\t\t\t\t\t\t\t<span className=\"dropdown-item\" onClick={() => this.setAlgorithm(\"Breadth First Search\")}>Breadth First Search</span>\r\n\t\t\t\t\t\t\t\t<span className=\"dropdown-item\" onClick={() => this.setAlgorithm(\"Depth First Search\")}>Depth First Search</span>\r\n\t\t\t\t\t\t\t\t<span className=\"dropdown-item\" onClick={() => this.setAlgorithm(\"Dijkstra's\")}>Dijkstra's</span>\r\n\t\t\t\t\t\t\t\t<span className=\"dropdown-item\" onClick={() => this.setAlgorithm(\"Greedy's\")}>Greedy's</span>\r\n\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t</li>\r\n\r\n\t\t\t\t\t\t<li className=\"nav-item\">\r\n\t\t\t\t\t\t\t<span className=\"nav-link\" onClick={() => this.visualizeSorting()}>Visualize {this.state.algorithm}</span>\r\n\t\t\t\t\t\t</li>\r\n\r\n\t\t\t\t\t\t<li className=\"nav-item dropdown\">\r\n\t\t\t\t\t\t\t<span className=\"nav-link dropdown-toggle\" id=\"mazeDropdown\" role=\"button\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">Generate Maze</span>\r\n\t\t\t\t\t\t\t<div className=\"dropdown-menu\" aria-labelledby=\"mazeDropdown\">\r\n\t\t\t\t\t\t\t\t<span className=\"dropdown-item\" onClick={() => this.generateMaze(\"Simple Wall\")}>Simple Wall</span>\r\n\t\t\t\t\t\t\t\t<span className=\"dropdown-item\" onClick={() => this.generateMaze(\"Recursive Backtracking\")}>Recursive Backtracking</span>\r\n\t\t\t\t\t\t\t\t<span className=\"dropdown-item\" onClick={() => this.generateMaze(\"Recursive Division\")}>Recursive Division</span>\r\n\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t</li>\r\n\r\n\t\t\t\t\t\t<li className=\"nav-item\">\r\n\t\t\t\t\t\t\t<span className=\"nav-link\" onClick={() => this.resetGridData()}>Reset Path</span>\r\n\t\t\t\t\t\t</li>\r\n\r\n\t\t\t\t\t\t<li className=\"nav-item\">\r\n\t\t\t\t\t\t\t<span className=\"nav-link\" onClick={() => this.resetGrid()}>Reset Grid</span>\r\n\t\t\t\t\t\t</li>\r\n\r\n\t\t\t\t\t</ul>\r\n\t\t\t\t</div>\r\n\t\t\t</nav>\r\n\t\t);\r\n\t}\r\n\r\n\trender() {\r\n\t\tconst { grid, mouseIsPressed } = this.state;\r\n\r\n\t\treturn (\r\n\t\t\t<div className=\"pathfinding-container\">\r\n\r\n\t\t\t\t{\r\n\t\t\t\t\tthis.generateNavbar()\r\n\t\t\t\t}\r\n\r\n\t\t\t\t<div className=\"grid\">\r\n\t\t\t\t\t{grid.map((row, rowIdx) => {\r\n\t\t\t\t\t\treturn (\r\n\t\t\t\t\t\t\t<div key={rowIdx} className=\"row\">\r\n\t\t\t\t\t\t\t\t{row.map((node, nodeIdx) => {\r\n\t\t\t\t\t\t\t\t\tconst { row, col, isFinish, isStart, isWall } = node;\r\n\t\t\t\t\t\t\t\t\treturn (\r\n\t\t\t\t\t\t\t\t\t\t<Node\r\n\t\t\t\t\t\t\t\t\t\t\tkey={nodeIdx}\r\n\t\t\t\t\t\t\t\t\t\t\tcol={col}\r\n\t\t\t\t\t\t\t\t\t\t\tisFinish={isFinish}\r\n\t\t\t\t\t\t\t\t\t\t\tisStart={isStart}\r\n\t\t\t\t\t\t\t\t\t\t\tisWall={isWall}\r\n\t\t\t\t\t\t\t\t\t\t\tmouseIsPressed={mouseIsPressed}\r\n\t\t\t\t\t\t\t\t\t\t\tonMouseDown={(row, col, wall) => this.handleMouseDown(row, col, wall)}\r\n\t\t\t\t\t\t\t\t\t\t\tonMouseEnter={(row, col) =>\r\n\t\t\t\t\t\t\t\t\t\t\t\tthis.handleMouseEnter(row, col)\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\tonMouseUp={() => this.handleMouseUp()}\r\n\t\t\t\t\t\t\t\t\t\t\trow={row}></Node>\r\n\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t})}\r\n\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t})}\r\n\t\t\t\t</div>\r\n\t\t\t</div>\r\n\t\t);\r\n\t}\r\n\r\n\r\n\tgetInitialGrid() {\r\n\t\tconst grid = [];\r\n\t\tgridWidth = Math.floor(window.innerWidth / 25);\r\n\t\tgridHeight = Math.floor((window.innerHeight - 100) / 25);\r\n\r\n\t\tSTART_NODE_COL = gridWidth >= 30 ? 10 : 1;\r\n\t\tSTART_NODE_ROW = Math.floor(gridHeight / 2);\r\n\t\tFINISH_NODE_COL = gridWidth >= 30 ? gridWidth - 10 : gridWidth - 1;\r\n\t\tFINISH_NODE_ROW = Math.floor(gridHeight / 2);\r\n\r\n\t\tif (START_NODE_COL % 2 === 0) START_NODE_COL++;\r\n\t\tif (START_NODE_ROW % 2 === 0) START_NODE_ROW++;\r\n\t\tif (FINISH_NODE_COL % 2 === 0) FINISH_NODE_COL++;\r\n\t\tif (FINISH_NODE_ROW % 2 === 0) FINISH_NODE_ROW++;\r\n\r\n\t\tfor (let row = 0; row < gridHeight; row++) {\r\n\t\t\tconst currentRow = [];\r\n\t\t\tfor (let col = 0; col < gridWidth; col++) {\r\n\t\t\t\tlet node = this.createNode(col, row);\r\n\t\t\t\tcurrentRow.push(node);\r\n\t\t\t}\r\n\t\t\tgrid.push(currentRow);\r\n\t\t}\r\n\t\treturn grid;\r\n\t};\r\n\r\n\tcreateNode(col, row) {\r\n\t\tlet n = {\r\n\t\t\tdistance: Infinity,\r\n\t\t\tcol: col,\r\n\t\t\trow: row,\r\n\t\t\tisStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n\t\t\tisFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n\t\t\tisMazeVisited: false,\r\n\t\t\tisMazeVisitedVisited: false,\r\n\t\t\tisVisited: false,\r\n\t\t\tisWall: false,\r\n\t\t\tpreviousNode: null\r\n\t\t};\r\n\t\treturn n;\r\n\t};\r\n\r\n\tgetNewGridWithWallToggled(grid, row, col) {\r\n\t\tconst newGrid = grid.slice();\r\n\t\tconst node = newGrid[row][col];\r\n\r\n\t\tconst isWall = node.isStart || node.isFinish ? false : this.dragData.walls;\r\n\t\tconst newNode = {\r\n\t\t\t...node,\r\n\t\t\tisWall: isWall,\r\n\t\t};\r\n\t\tnewGrid[row][col] = newNode;\r\n\r\n\t\tthis.updateNodeClassNames(newNode);\r\n\r\n\t\treturn newGrid;\r\n\t};\r\n\r\n\tupdateStartAndFinishPositions(newStartNodeRow, newStartNodeCol, newFinishNodeRow, newFinishNodeCol) {\r\n\t\tSTART_NODE_COL = newStartNodeCol;\r\n\t\tSTART_NODE_ROW = newStartNodeRow;\r\n\t\tFINISH_NODE_COL = newFinishNodeCol;\r\n\t\tFINISH_NODE_ROW = newFinishNodeRow;\r\n\r\n\t\tlet newGrid = this.state.grid;\r\n\t\tfor (let row of newGrid) {\r\n\t\t\tfor (let node of row) {\r\n\t\t\t\tnode.isStart = false;\r\n\t\t\t\tnode.isFinish = false;\r\n\t\t\t\tthis.updateNodeClassNames(node, \" node-instant-animation\");\r\n\t\t\t}\r\n\t\t}\r\n\t\tnewGrid[newStartNodeRow][newStartNodeCol].isStart = true;\r\n\t\tthis.updateNodeClassNames(newGrid[newStartNodeRow][newStartNodeCol]);\r\n\t\tnewGrid[newFinishNodeRow][newFinishNodeCol].isFinish = true;\r\n\t\tthis.updateNodeClassNames(newGrid[newFinishNodeRow][newFinishNodeCol]);\r\n\t};\r\n\r\n\tgetNodeClassNames(node) {\r\n\t\tlet extraClassName = \"node\";\r\n\t\textraClassName += node.isStart ? \" node-start\" : \"\";\r\n\t\textraClassName += node.isFinish ? \" node-finish\" : \"\";\r\n\t\textraClassName += node.isWall && !node.isStart && !node.isFinish ? \" node-wall\" : \"\";\r\n\t\textraClassName += node.isVisited ? \" node-visited\" : \"\";\r\n\t\treturn extraClassName;\r\n\t}\r\n\r\n\tupdateNodeClassNames(node, extraClassName) {\r\n\t\tdocument.getElementById(`node-${node.row}-${node.col}`).className = this.getNodeClassNames(node) + (extraClassName ? extraClassName : \"\");\r\n\t}\r\n\r\n}","\r\nexport function simpleWall(grid, totalWidth, totalHeight) {\r\n\r\n    let wallsInOrder = [];\r\n\r\n    let deltaX = 1, deltaY = -1;\r\n    let currentX = 0, currentY = Math.floor(totalHeight / 2);\r\n\r\n    while (currentX < totalWidth - 1) {\r\n        if (!grid[currentY][currentX].isStart && !grid[currentY][currentX].isFinish)\r\n            wallsInOrder.push(grid[currentY][currentX]);\r\n        \r\n        currentX += deltaX;\r\n        currentY += deltaY;\r\n\r\n        if (currentY <= 1) {\r\n            deltaY = 1;\r\n        }\r\n\r\n        if (currentY >= totalHeight - 2) {\r\n            deltaY = -1;\r\n        } \r\n    }\r\n\r\n    return {\r\n        wallsInOrder: wallsInOrder,\r\n        wallsToRemove: []\r\n    };\r\n}","import React from 'react';\nimport PathfindingVisualizer from './PathfindingVisualizer/PathfindingVisualizer';\n\nfunction App() {\n\treturn (\n\t\t<div className=\"App\">\n\t\t\t<PathfindingVisualizer></PathfindingVisualizer>\n\t\t</div>\n\t);\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}